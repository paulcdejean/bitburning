// Attempts to balance grow, hack and weaken to sustainably farm a target.
// var args[0] = the target
// var args[1] = the number of threads to farm with, if no argument passed it uses all available threads

import { getNodes } from "/lib/getNodes.script"
import { doRemote } from "/lib/doRemote.script"
import { getThreadCount } from "/lib/getThreadCount.script"
import { getLock } from "/lib/getLock.script"
import { releaseLock } from "/lib/releaseLock.script"

farmTarget(getNodes(), args[0], args[1])

function farmTarget(nodes, target, threads) {
	// Boilerplate
	var remoteGrowName = "/remotes/grow.script"
	var remoteWeakenName = "/remotes/weaken.script"
	var remoteHackName = "/remotes/hack.script"
	var remoteRam = Math.max(getScriptRam(remoteGrowName), getScriptRam(remoteWeakenName), getScriptRam(remoteHackName))
	var availableThreads = getThreadCount(nodes, remoteRam)
	var growTime = getGrowTime(target)
	var hackTime = getHackTime(target)
	var weakenTime = getWeakenTime(target)
	var hackRate = hackAnalyze(target)
	var growDelay = weakenTime - growTime
	var farmPort = 4

	// Sanity checks
	if (!target) {
		tprint("Specifying a target is required")
		return
	}
	var targetMinSecurity = getServerMinSecurityLevel(target)
	if (targetMinSecurity != getServerSecurityLevel(target)) {
		tprint("Target ", target, " must be weakened first before trying to grow it.")
		return
	}
	if (getServerMaxMoney(target) != getServerMoneyAvailable(target)) {
		tprint("Target ", target, " must be grown to max money first before trying to farm it.")
		return
	}

	// Threading logic.
	if (!threads) {
		var threads = availableThreads
		tprint("Farming ", target, " with all available threads ", threads)
	} else if (threads > availableThreads) {
		var threads = availableThreads
		tprint("Insufficent threads to fufil request, farming ", target, " with all remaining threads ", threads)
	} else {
		tprint("Farming ", target, " with ", threads, " threads")
	}

	// The 1.10 is a heuristic
	// Because the 2nd, 3rd, 4th etc hacks before the weaken don't run at min security...
	var hackCount = Math.floor(weakenTime / (hackTime * 1.10))

	var growMin = 0
	// Random cutoff
	var growMax = 32
	var growAverage = 2
	var nuttyThreads = growthAnalyze(target, 1 + growMax)
	if (nuttyThreads < threads) {
		tprint("Your requested threads are too powerful for this target")
		return
	}

	var currentThreads = 1
	while (currentThreads != threads) {
		var growAverage = (growMin + growMax) / 2
		var currentThreads = Math.floor(growthAnalyze(target, 1 + growAverage))
		if (currentThreads > threads) {
			var growMax = growAverage
		} else if (currentThreads < threads) {
			var growMin = growAverage
		}
	}
	var maxGrowthAmount = 1 + growAverage
	var minAmountToLeave = 1 / maxGrowthAmount
	var minAmountToLeavePerhack = Math.pow(minAmountToLeave, (1 / hackCount))
	var maxHackageAmountPerHack = 1 - minAmountToLeavePerhack

	var maxHackingThreads = Math.floor(maxHackageAmountPerHack / hackRate)

	print("Max hacking threads: ", maxHackingThreads)

	var hackRatio = maxHackingThreads / (threads + maxHackingThreads)
	var growRatio = threads / (threads + maxHackingThreads)
	var hackgrowSecurity = (0.002 * hackCount * hackRatio) + (growRatio * 0.004)
	var weakenPer = hackgrowSecurity / 0.05
	var hackgrowRatio = 1 / (1 + weakenPer)
	var weakenRatio = 1 - hackgrowRatio
	var hackgrowThreads = Math.floor(hackgrowRatio * threads)
	var weakenThreads = Math.ceil(weakenRatio * threads)
	var growThreads = Math.ceil(growRatio * hackgrowThreads)
	var hackThreads = Math.floor(hackRatio * hackgrowThreads)

	print("Hack rate: ", hackRate)
	print("Max growth amount: ", maxGrowthAmount)
	print("Min amount to leave: ", minAmountToLeave)
	print("Min amount to leave per hack: ", minAmountToLeavePerhack)
	print("Max hackage amount per hack: ", maxHackageAmountPerHack)
	
	print("Number of hacks per cycle: ", hackCount)
	print("Weaken threads: ", weakenThreads)
	print("Hackgrow threads: ", hackgrowThreads)
	print("Grow threads: ", growThreads)
	print("Hack threads: ", hackThreads)
	print("Max money: ", getServerMaxMoney(target))
	print("Min security: ", getServerMinSecurityLevel(target))


	getLock()
	tprint("Aquired lock for farmTarget on ", target)
	doRemote(nodes, weakenThreads, remoteWeakenName, remoteRam, [farmPort, target])
	doRemote(nodes, growThreads, remoteGrowName, remoteRam, [farmPort, target, growDelay])
	doRemote(nodes, hackThreads, remoteHackName, remoteRam, [farmPort, target, hackCount])
	tprint("Farming ", target, " with hacking threads ", hackThreads,
		" grow threads ", growThreads, " and weaken threads ", weakenThreads)
	var daemonArgs = ["/daemons/farm.script", "home", 1, target, weakenTime + 1000]
	exec.apply(null, daemonArgs)
	releaseLock()
	tprint("Released lock for farmTarget on ", target)
	return daemonArgs
}