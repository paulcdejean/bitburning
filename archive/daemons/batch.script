// This daemon publishes info to port 6 that keeps remotes in sync

daemonBatch(args[0], args[1], args[2], args[3], args[4], args[5], args[6])

function daemonBatch(target, batches, hackCount, hackThreads, opBuffer, batchBuffer, cycleBuffer) {

	// yes all args are required
	if (target === undefined) {
		tprint("ERROR: target must be defined")
		return
	}
	if (batches === undefined) {
		tprint("ERROR: batches must be defined")
		return
	}
	if (hackCount === undefined) {
		tprint("ERROR: hackCount must be defined")
		return
	}
	if (hackThreads === undefined) {
		tprint("ERROR: hackThreads must be defined")
		return
	}
	if (opBuffer === undefined) {
		tprint("ERROR: opBuffer must be defined")
		return
	}
	if (batchBuffer === undefined) {
		tprint("ERROR: batchBuffer must be defined")
		return
	}
	if (cycleBuffer === undefined) {
		tprint("ERROR: cycleBuffer must be defined")
		return
	}

	tprint(target)
	var daemonPort = 6

	// Unchanging
	var minSecurity = getServerMinSecurityLevel(target)
	var maxMoney = getServerMaxMoney(target)

	// Main
	tprint("Daemon started for batch farming ", target, " with ", batches, " batches")

	var portData = {}

	var cycle = 0
	while (true) {
		var cycle = cycle + 1

		var currentMoney = getServerMoneyAvailable(target)
		var currentSecurity = getServerSecurityLevel(target)
		var weakenTime = getWeakenTime(target)
		var growTime = getGrowTime(target)
		var hackTime = getHackTime(target)

		// Divined using the formulas API
		var hackGrowthPerSecurity = hackTime / (200 + minSecurity)
		var worstCaseTotalHackTime = (hackTime * hackCount) +
			(hackGrowthPerSecurity * batches * hackThreads * hackCount * 0.002 * (hackCount - 1))

		tprint(target, " cycle ", cycle,
			": money is ", nFormat(currentMoney, "0.000a"), " out of ", nFormat(maxMoney, "0.000a"),
			" and security is ", currentSecurity, " out of ", minSecurity)

		var minCycleTime = weakenTime - worstCaseTotalHackTime + (batches * batchBuffer) + opBuffer * 2
		var cycleTime = Math.max(weakenTime + cycleBuffer, minCycleTime)
		

		if (cycleTime <= minCycleTime) {
			tprint("WARNING min cycle time reached for ", target)
			cycleTime = minCycleTime
		}


		var batch = 0
		var batchArray = []
		while (batch < batches) {
			var batchWeakenDelay = batch * batchBuffer + cycleTime - weakenTime - cycleBuffer
			var batchGrowDelay = batch * batchBuffer + cycleTime - growTime - cycleBuffer - opBuffer
			var batchHackDelay = batch * batchBuffer + cycleTime - worstCaseTotalHackTime - cycleBuffer - opBuffer * 2
			batchArray.push({
				"weaken": batchWeakenDelay,
				"grow": batchGrowDelay,
				"hack": batchHackDelay
			})
			batch = batch + 1
		}

		cycleObject = {
			"cycle": cycle,
			"batches": batchArray
		}

		// Write data to port
		var portString = "NULL PORT DATA"
		while (portString == "NULL PORT DATA") {
			var portString = readPort(daemonPort)
		}
		var portData = JSON.parse(portString)
		portData[target] = cycleObject
		writePort(daemonPort, JSON.stringify(portData))

		return
	}
}