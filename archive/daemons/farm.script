// Farms a node keeping it at max money.
// This doesn't launch the remotes but it supervises them.
// Doesn't currently terminate
import { getNodes } from "/lib/getNodes.script"

daemonFarm(args[0], args[1])

function daemonFarm(target, cycleTime) {
	// Boilerplate
	disableLog("getServerMoneyAvailable")
	disableLog("getServerSecurityLevel")
	disableLog("sleep")
	var nodes = getNodes()
	var targetMaxMoney = nodes[target]["maxMoney"]
	var targetMinSecurity = nodes[target]["minSecurity"]
	var daemonPort = 4

	// Money can drift due to changing hacking levels. This sets what sort of drift we accept.
	var moneyDriftTolerance = 0.75

	// Main
	tprint("Daemon started for farming ", target)

	var cycle = 0
	while (true) {
		var cycle = cycle + 1

		var portString = "NULL PORT DATA"
		while (portString == "NULL PORT DATA") {
			var portString = readPort(daemonPort)
		}
		var portData = JSON.parse(portString)
		portData[target] = cycle
		writePort(daemonPort, JSON.stringify(portData))
		sleep(cycleTime)
		var currentMoney = getServerMoneyAvailable(target)
		var currentSecurity = getServerSecurityLevel(target)
		print("After ", cycle, " cycles ", target, " money is ",
			currentMoney.toLocaleString(), " and security is ", currentSecurity)
		if (currentMoney < targetMaxMoney * 0.75 || currentSecurity > targetMinSecurity * 1.1) {
			tprint("ERROR after ", cycle, " cycles ", target, " money is ",
				currentMoney.toLocaleString(), " and security is ", currentSecurity.toFixed(3))
			while (true) {
				tprint("ERROR freezing farming for ", target)
				sleep(10000000)
			}
		} else if (currentMoney < targetMaxMoney || currentSecurity > targetMinSecurity) {
			tprint("WARNING after ", cycle, " cycles ", target, " money is ",
				currentMoney.toLocaleString(), " and security is ", currentSecurity.toFixed(3))
		}
	}
}